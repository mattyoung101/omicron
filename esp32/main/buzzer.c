/*
 * This file is part of the ESP32 firmware project.
 * Copyright (c) 2019-2020 Team Omicron. All rights reserved.
 *
 * Team Omicron members: Lachlan Ellis, Tynan Jones, Ethan Lo,
 * James Talkington, Matt Young.
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */
#include <buzzer.h>

// Generated by midi_processor.py (original file: midis/SoundTest.mid)
music_note_t SOUNDTEST[248] = {{1, 261, 0}
, {1, 329, 600}, {1, 391, 600}, {1, 523, 600}, {0, 261, 600}, {0, 329, 0}, {0, 391, 0}, {0, 523, 0}
, {1, 261, 150}, {1, 329, 75}, {1, 391, 75}, {1, 523, 75}, {0, 261, 224}, {0, 329, 0}, {0, 391, 0}
, {0, 523, 0}, {1, 293, 600}, {1, 349, 600}, {1, 440, 600}, {1, 587, 600}, {0, 293, 600}, {0, 349, 0}
, {0, 440, 0}, {0, 587, 0}, {1, 293, 150}, {1, 349, 75}, {1, 440, 75}, {1, 587, 75}, {0, 293, 224}
, {0, 349, 0}, {0, 440, 0}, {0, 587, 0}, {1, 329, 600}, {1, 391, 600}, {1, 493, 600}, {1, 659, 600}
, {0, 329, 600}, {0, 391, 0}, {0, 493, 0}, {0, 659, 0}, {1, 329, 150}, {1, 391, 75}, {1, 493, 75}
, {1, 659, 75}, {0, 329, 224}, {0, 391, 0}, {0, 493, 0}, {0, 659, 0}, {1, 261, 600}, {0, 261, 150}
, {1, 329, 0}, {0, 329, 150}, {1, 391, 0}, {0, 391, 150}, {1, 261, 0}, {0, 261, 150}, {1, 329, 0}
, {0, 329, 150}, {1, 391, 0}, {0, 391, 150}, {1, 261, 0}, {0, 261, 150}, {1, 329, 0}, {0, 329, 150}
, {1, 391, 0}, {0, 391, 150}, {1, 261, 0}, {0, 261, 150}, {1, 329, 0}, {0, 329, 150}, {1, 391, 0}
, {0, 391, 150}, {1, 261, 0}, {0, 261, 150}, {1, 329, 0}, {0, 329, 150}, {1, 391, 0}, {0, 391, 150}
, {1, 261, 0}, {0, 261, 150}, {1, 293, 0}, {0, 293, 150}, {1, 349, 0}, {0, 349, 150}, {1, 440, 0}
, {0, 440, 150}, {1, 293, 0}, {0, 293, 150}, {1, 349, 0}, {0, 349, 150}, {1, 440, 0}, {0, 440, 150}
, {1, 293, 0}, {0, 293, 150}, {1, 349, 0}, {0, 349, 150}, {1, 440, 0}, {0, 440, 150}, {1, 293, 0}
, {0, 293, 150}, {1, 349, 0}, {0, 349, 150}, {1, 440, 0}, {0, 440, 150}, {1, 293, 0}, {0, 293, 150}
, {1, 349, 0}, {0, 349, 150}, {1, 440, 0}, {0, 440, 150}, {1, 293, 0}, {0, 293, 150}, {1, 329, 0}
, {0, 329, 150}, {1, 391, 0}, {0, 391, 150}, {1, 493, 0}, {0, 493, 150}, {1, 329, 0}, {0, 329, 150}
, {1, 391, 0}, {0, 391, 150}, {1, 493, 0}, {0, 493, 150}, {1, 329, 0}, {0, 329, 150}, {1, 391, 0}
, {0, 391, 150}, {1, 493, 0}, {0, 493, 150}, {1, 329, 0}, {0, 329, 150}, {1, 391, 0}, {0, 391, 150}
, {1, 493, 0}, {0, 493, 150}, {1, 329, 0}, {0, 329, 150}, {1, 391, 0}, {0, 391, 150}, {1, 493, 0}
, {0, 493, 150}, {1, 329, 0}, {0, 329, 150}, {1, 391, 0}, {0, 391, 150}, {1, 466, 0}, {0, 466, 150}
, {1, 587, 0}, {0, 587, 150}, {1, 391, 0}, {0, 391, 150}, {1, 466, 0}, {0, 466, 150}, {1, 587, 0}
, {0, 587, 150}, {1, 391, 0}, {0, 391, 150}, {1, 466, 0}, {0, 466, 150}, {1, 587, 0}, {0, 587, 150}
, {1, 391, 0}, {0, 391, 150}, {1, 466, 0}, {0, 466, 150}, {1, 587, 0}, {0, 587, 150}, {1, 391, 0}
, {0, 391, 150}, {1, 466, 0}, {0, 466, 150}, {1, 587, 0}, {0, 587, 150}, {1, 391, 0}, {0, 391, 150}
, {1, 32, 1200}, {0, 32, 300}, {1, 36, 0}, {0, 36, 300}, {1, 41, 0}, {0, 41, 300}, {1, 43, 0}
, {0, 43, 300}, {1, 48, 0}, {0, 48, 300}, {1, 55, 0}, {0, 55, 300}, {1, 61, 0}, {0, 61, 300}
, {1, 65, 0}, {0, 65, 300}, {1, 73, 0}, {0, 73, 300}, {1, 82, 0}, {0, 82, 300}, {1, 87, 0}
, {0, 87, 300}, {1, 97, 0}, {0, 97, 300}, {1, 110, 0}, {0, 110, 300}, {1, 123, 0}, {0, 123, 300}
, {1, 130, 0}, {0, 130, 300}, {1, 146, 0}, {0, 146, 300}, {1, 164, 0}, {0, 164, 300}, {1, 174, 0}
, {0, 174, 300}, {1, 195, 0}, {0, 195, 300}, {1, 220, 0}, {0, 220, 300}, {1, 246, 0}, {0, 246, 300}
, {1, 261, 0}, {0, 261, 300}, {1, 293, 0}, {0, 293, 300}, {1, 329, 0}, {0, 329, 300}, {1, 349, 0}
, {0, 349, 300}, {1, 391, 0}, {0, 391, 300}, {1, 440, 0}, {0, 440, 300}, {1, 493, 0}, {0, 493, 300}
, {1, 523, 0}, {0, 523, 300}, {1, 587, 0}, {0, 587, 300}, {1, 659, 0}, {0, 659, 300}, {1, 698, 0}
, {0, 698, 300}, {1, 783, 0}, {0, 783, 300}, {1, 880, 0}, {0, 880, 300}, {1, 987, 0}, {0, 987, 300}
, {1, 1046, 0}, {0, 1046, 1499}};

void buzzer_init(void){
    // Setup pins
    ESP_ERROR_CHECK(mcpwm_gpio_init(MCPWM_UNIT_0, MCPWM2A, BUZZER_1));
    ESP_ERROR_CHECK(mcpwm_gpio_init(MCPWM_UNIT_1, MCPWM0A, BUZZER_2));
    ESP_ERROR_CHECK(mcpwm_gpio_init(MCPWM_UNIT_1, MCPWM1A, BUZZER_3));
    ESP_ERROR_CHECK(mcpwm_gpio_init(MCPWM_UNIT_1, MCPWM2A, BUZZER_4));

    mcpwm_config_t config = {
        .frequency = 440.0, // Default frequency: A = 440
        .cmpr_a = 0.0f,
        .cmpr_b = 0.0f,
        .counter_mode = MCPWM_UP_COUNTER,
        .duty_mode = MCPWM_DUTY_MODE_0
    };

    ESP_ERROR_CHECK(mcpwm_init(MCPWM_UNIT_0, MCPWM_TIMER_2, &config));
    ESP_ERROR_CHECK(mcpwm_init(MCPWM_UNIT_1, MCPWM_TIMER_0, &config));
    ESP_ERROR_CHECK(mcpwm_init(MCPWM_UNIT_1, MCPWM_TIMER_1, &config));
    ESP_ERROR_CHECK(mcpwm_init(MCPWM_UNIT_1, MCPWM_TIMER_2, &config));

    ESP_ERROR_CHECK(mcpwm_start(MCPWM_UNIT_0, MCPWM_TIMER_2));
    ESP_ERROR_CHECK(mcpwm_start(MCPWM_UNIT_1, MCPWM_TIMER_0));
    ESP_ERROR_CHECK(mcpwm_start(MCPWM_UNIT_1, MCPWM_TIMER_1));
    ESP_ERROR_CHECK(mcpwm_start(MCPWM_UNIT_1, MCPWM_TIMER_2));
}

void play_frequency(float frequency, uint8_t number, uint8_t duration, uint8_t volume){
    static const char *TAG = "PlayNote";
    switch(number){
        case 1:
            mcpwm_set_frequency(MCPWM_UNIT_0, MCPWM_TIMER_2, frequency);
            mcpwm_set_duty(MCPWM_UNIT_0, MCPWM_TIMER_2, MCPWM_OPR_A, volume);
            mcpwm_set_duty_type(MCPWM_UNIT_0, MCPWM_TIMER_2, MCPWM_OPR_A, MCPWM_DUTY_MODE_0);
            vTaskDelay(pdMS_TO_TICKS(duration));
            mcpwm_set_duty(MCPWM_UNIT_0, MCPWM_TIMER_2, MCPWM_OPR_A, 0);
            break;
        case 2:
            mcpwm_set_frequency(MCPWM_UNIT_1, MCPWM_TIMER_0, frequency);
            mcpwm_set_duty(MCPWM_UNIT_1, MCPWM_TIMER_0, MCPWM_OPR_A, volume);
            mcpwm_set_duty_type(MCPWM_UNIT_1, MCPWM_TIMER_0, MCPWM_OPR_A, MCPWM_DUTY_MODE_0);
            vTaskDelay(pdMS_TO_TICKS(duration));
            mcpwm_set_duty(MCPWM_UNIT_1, MCPWM_TIMER_0, MCPWM_OPR_A, 0);
            break;
        case 3:
            mcpwm_set_frequency(MCPWM_UNIT_1, MCPWM_TIMER_1, frequency);
            mcpwm_set_duty(MCPWM_UNIT_1, MCPWM_TIMER_1, MCPWM_OPR_A, volume);
            mcpwm_set_duty_type(MCPWM_UNIT_1, MCPWM_TIMER_1, MCPWM_OPR_A, MCPWM_DUTY_MODE_0);
            vTaskDelay(pdMS_TO_TICKS(duration));
            mcpwm_set_duty(MCPWM_UNIT_1, MCPWM_TIMER_1, MCPWM_OPR_A, 0);
            break;
        case 4:
            mcpwm_set_frequency(MCPWM_UNIT_1, MCPWM_TIMER_2, frequency);
            mcpwm_set_duty(MCPWM_UNIT_1, MCPWM_TIMER_2, MCPWM_OPR_A, volume);
            mcpwm_set_duty_type(MCPWM_UNIT_1, MCPWM_TIMER_2, MCPWM_OPR_A, MCPWM_DUTY_MODE_0);
            vTaskDelay(pdMS_TO_TICKS(duration));
            mcpwm_set_duty(MCPWM_UNIT_1, MCPWM_TIMER_2, MCPWM_OPR_A, 0);
            break;
    }
    ESP_LOGD(TAG, "Playing %f Hz on buzzer %d for %d ms and %d volume", frequency, number, duration, volume);
}

void play_voice(music_note_t *voice, uint8_t buzzerNum, uint8_t volume){
    static const char *TAG = "PlayVoice";
    size_t arrayLength = 248;

    ESP_LOGD(TAG, "Song length: %d", arrayLength);

    for(int i = 0; i < arrayLength; i++){
        uint8_t _volume = voice[i].type == 0 ? 0 : volume;
        play_frequency(voice[i].frequency, buzzerNum, voice[i].time, _volume);
    }
}

void play_song(uint8_t volume){
    play_voice(SOUNDTEST, 1, 100);
}